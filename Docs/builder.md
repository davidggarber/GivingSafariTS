Buider HTML is loosely inspired by React or ASP.  
It defines the data first.  
Then the HTML supports special tags for loops and conditionals,  
and the text and attributes support lookups into the data.  
  
# Data initialization:
In the script block of the page, add two values to the boilerplate:

```
const boiler = {
  ...
  'reactiveBuilder': true,  // required
  'builderLookup': {        // free-form, for example...
    magic: 123,
    line: { start: {x:1, y:2}, end: {x:3, y:4} },
    fonts: [ 'bold', 'italic' ],
    grid: [
      [1, 2, 3],
      [4, 5, 6]
    ]
  }
};
``` 

# Data lookup:
In HTML text or attribute values, use curly-brace syntax to inject named values:

Examples in text:

Example  | Generated   | Notes
---------|-------------|----------
`{magic}` | 123 |
`{line.end.x}` | 3 |
`{grid.0.1}` | 2 | _note that .0 and .1 are indeces_
      
Examples in attributes:

Example | Generated | Notes
--------|-----------|-------
`<div id="{magic}" class="{fonts.0} {fonts.1}">` | <div id="123" class="bold italic">
`<img_ src_="{fonts.0}Icon.png">` | \<img src="boldIcon.png"> | There is a special rule for tags and attributes suffixed with _ <br> when you need to avoid the pre-processed tags/attributes being acted upon by the DOM.
`{grid.[line.start.x].[line.start.y]}` | 5  (same as {grid.1.2}) | Parameterized lookups allow one lookup to be used to name the child of another. <br> Any nested pair of **\[brackets]** restarts the lookup context at the root.
  
# \<for> Loops:
Use the new **\<for>** tag to loop over a set of values,  
cloning and re-evaluating the contents of the loop for each.  

The targets of loops are implicitly lookups, so the {curly} syntax is not needed.  
As they expand, new nested values are dynamically added to the lookup table, to reflect the loop state.  

There are several variant syntaxes of \<for> loop, differentiated by the first attribute, which names the iterator.
Within the body of the \<for> tags, new temporary lookup values are available, based on the iterator names.

List type | Syntax | Generates | Notes
----------|--------|-----------|------
**Each** element in a list | `<for each="font" in="fonts">{font#}:{font} </for>` | 0:bold 1:italic | `{font}` is the element <br> `{font#}` is the index (starting at 0)
**Key**s in an object | `<for key="a" in="line.end">{a#}:{a}={a!} </for>` | 0:x=3 1:y=4 | `{a}` is the key <br> `{a!}` is the value <br> `{a#}` is the index
**Char**acters in text | `<for char="ch" in="fonts.0">{ch} </for>` <br> `<for char="ch" in="other">{ch} </for>` | b o l d <br> o t h e r | Note that the `in="value"` can be a literal.
**Word**s in text | `<for char="w" in="Hello World!">{w}-{w}</for>` | Hello-HelloWorld!-World! | A word is really anything delimited by spaces.
**Range**s of values | `<for range="i" from="1" to="3">{i}</for>` <br> `<for range="i" from="1" until="3">{i}</for>` <br> `<for range="i" from="5" to="0" step="-2">{i}</for>` <br> `<for range="i" length="fonts">{fonts.[i]} </for>` | 123 <br> 12 <br> 531 <br> bold italic | `from=""`   specifies the start value (default 0) <br> `to=""` specifies the last value (inclusive) <br> `until=""` specifies a stop value (exclusive) <br> `length=""` is equivalent to until=length-of-list <br> `step=""` specifies a step value, if not 1
| | `<for range="row" from="0" to="1"><for range="col" from="0" to="2">{grid.[row].[col]}</for>,</for>` | 123,456 | Use ranges in compound lookups

# \<if> conditionals
Use the new **\<if>** tag to check a lookup against various states.  
The checked values are implicitly lookups, so the {curly} syntax is not needed.  
No new temporary values are generated by ifs.  

Note: there is no else syntax. Instead, concatenate multiple ifs.
As such, be careful not to nest, unless intended.
 
Example | Generates 
--------|-----------
`<if test="magic" eq="123">Magic!</if>` <br> `<if test="magic" ne="123">Lame.</if>` | Magic!
`<if test="magic" ge="100">Big!` <br> `<if test="magic" ge="120">Bigger!</if>` <br> `</if>` | Big!Bigger!
  
Attributes | Operations
-----------|------------
`eq="x"`      | Equals "x" _(always case-sensitive)_
`ne=" "`      | Not-equals a space
`gt="0"`      | Greater than 0
`lt="10"`     | Less than 10
`ge="0"`      | Greater than or equals 0
`le="9"`      | Less than or equals 9
`in="super"`  | Test value is IN (a substring of) "super"
`ni="super"`  | Test value is NOT IN (not a substring of) "super"

_There is no NOT modifier. Instead, use the converse operator._  
_Nor are the AND or OR modifiers. Consider secondary lookup tables._  
 
  
## Incompatibility with Tables:
It is tempting to use loops inside \<table> tags.  
However, the DOM will likely refactor them if found inside a \<table> but not inside a \<td>.

Two options:
sufix_ syntax | CSS
---------------|-----
`<table_>` <br>&nbsp;&nbsp;`<for ...>` <br>&nbsp;&nbsp;&nbsp;&nbsp;`<tr_>...</tr_>` <br>&nbsp;&nbsp;`</for>` <br> `</table_>` | `<div style="display:table">` <br>&nbsp;&nbsp;`<for ...>` <br>&nbsp;&nbsp;&nbsp;&nbsp;`<div style="display:table-row">...</div>` <br>&nbsp;&nbsp;`</for>` <br> `</div>`

# Text input shortcuts

The builder defines several custom tags
import { _rawHtmlSource } from "./_boilerplate";

/**
 * Convert an error's stack trace (run-on text stream) into a list.
 * @param ex An error. Better yet, a BuildError-derived error.
 * @returns The stack as a list, where item 0 is the message.
 * If ex is a BuildError, re-use the cached stack read.
 */
function stackAsList(ex:Error):string[] {
  if ((<BuildError>ex).relativeStack) {  // instanceof BuildError
    return (<BuildError>ex).relativeStack;
  }

  if (!ex.stack) {
    return [];
  }
  return ex.stack.split('\n');
}

/**
 * Make a stack at the current callstack, by faking an exception.
 * @param remove A list of functions to remove - the debug infrastructure to capture these callstacks.
 * @param summary The correct first line of the stack, to replace a generic one generated by the fake exception.
 * @returns A callstack as a list
 */
function debugMakeStack(remove:string[], summary?:string):string[] {
  const ex = new Error();
  const stack = stackAsList(ex);
  cleanStack(stack, ['stackAsList', 'debugMakeStack']);
  cleanStack(stack, remove, summary);
  return stack;
}

/**
 * Compare an outer and inner/causal callstack.
 * @param err The inner exception.
 * @param caller The callstack (as a list) of the outer/calling exception.
 * @returns The portion of inner's callstack that adds to the callstack of the caller.
 */
function simplifyRelativeStack(err:Error, caller:string[]):string[] {
  let inner:string[] = stackAsList(err);
  let firstAt = 0;
  while (firstAt < inner.length && inner[firstAt].indexOf(' at ') < 0) {
    firstAt++;
  }

  for (let i = firstAt; i < inner.length; i++) {
    for (let c = 0; c < caller.length; c++) {
        if (inner[i] == caller[c]) {
            // Found first match. Remove everything in inner from here on.
            inner.splice(i, inner.length - i);
            return inner;
        }
    }
  }
  return inner;
}

/**
 * Clean a callstack by removing the infrastructure for getting callstacks.
 * @param stack The callstack to modify.
 * @param remove The function entries to remove.
 * @param summary An optional new summary message (line 0)
 */
function cleanStack(stack:string[], remove:string[], summary?:string) {
  let firstAt = 0;
  while (firstAt < stack.length && stack[firstAt].indexOf(' at ') < 0) {
    firstAt++;
  }
  let cleaned = true;
  while (stack.length > firstAt && cleaned) {
    for (let i = 0; i < remove.length; i++) {
      cleaned = false;
      if (stack[firstAt].indexOf(remove[i]) >= 0) {
        stack.splice(firstAt, 1);
        cleaned = true;
        break;
      }
    }
  }

  if (summary) {
    if (firstAt > 0) {
      stack[0] = summary;
    }
  }
}

/**
 * Create an error message, which also mentions causal messages (if any)
 * @param msg The current error message
 * @param cause An inner exception (which could have nested inners)
 * @returns Either the original message, or the message combined with nested messages.
 */
function concatErrorMessage(msg:string, cause?:Error) {
  if (!cause) {
    return msg;
  }
  return msg + "\n caused by " + cause.message;
}

/**
 * Custom error which can track nested exceptions
 */
export class BuildError extends Error {
  public cause: Error|undefined;
  public relativeStack: string[];

  /**
   * Create a new BuildError (or derived error)
   * @param msg The message of the Error
   * @param inner The inner/causal error, if any
   * @param cls The name of the derived class, if any
   */
  constructor(msg: string, inner?:Error, cls?:string) {
    super(concatErrorMessage((cls || "BuildError") + ": " + msg, inner));
    this.name = 'BuildError';
    this.cause = inner;
    this.relativeStack = debugMakeStack(['.Build', 'new Build'], (cls || "BuildError") + ": " + msg);

    if (inner) {
      if ((<BuildHtmlError>inner).location) {  // instanceof BuildHtmlError
        inner.stack = (<BuildHtmlError>inner).tag + ' (' + (<BuildHtmlError>inner).location + ')';
        (<BuildError>inner).relativeStack = [inner.stack];
      }
      else {
        const innermost = simplifyRelativeStack(inner, this.relativeStack);
        if ((<BuildError>inner).relativeStack) {  // instanceof BuildError
          (<BuildError>inner).relativeStack = innermost;
          inner.stack = innermost.join('\n');
        }  
      }
    }
  }
}

/**
 * Track build errors that occur while evaluating context expressions.
 * Intended use is 1-per-function, in a function-wide try/catch
 */
export class BuildEvalError extends BuildError {
  public raw: string;

  /**
   * @param func The name of the function.
   * @param inner The inner/causal error, if any
   * @param cls The name of the derived class, if any
   */
  constructor(func: string, raw:string, inner?:Error, cls?:string) {
    super(func + '(' + raw + ')', inner, cls || "BuildEvalError");
    this.name = 'BuildEvalError';
    this.raw = raw;
  }
}

/**
 * Track build errors that occur while evaluating build tags.
 * Intended use is 1-per-function, in a function-wide try/catch
 */
export class BuildTagError extends BuildError {
  public tag: string;

  /**
   * @param func The name of the function.
   * @param inner The inner/causal error, if any
   * @param cls The name of the derived class, if any
   */
  constructor(func: string, elmt:Element, inner?:Error, cls?:string) {
    super(func + '(' + debugTagAttrs(elmt) + ')', inner, cls || "BuildTagError");
    this.name = 'BuildTagError';
    this.tag = debugTagAttrs(elmt);
  }
}

/**
 * Track build errors back to their location in the HTML
 */
export class BuildHtmlError extends BuildError {
  public tag: string;
  public location: string;

  /**
   * @param msg The description of the problem
   * @param elmt The HTML element that is mal-formed
   * @param inner The inner/causal error, if any
   * @param cls The name of the derived class, if any
   */
  constructor(msg: string, elmt:Element, inner?:Error, cls?:string) {
    super(msg, inner, cls || "BuildHtmlError");
    this.name = 'BuildHtmlError';
    this.tag = debugTagAttrs(elmt);
    this.location = debugLocateTag(elmt, true);
  }
}

/**
 * For debug traces, summarize a tag without including its children/contents
 * @param elmt Any HTML element
 * @returns A recreation of its start tag
 */
function debugTagAttrs(elmt:Element): string {
  let str = '<' + elmt.localName;
  for (let i = 0; i < elmt.attributes.length; i++) {
    str += ' ' + elmt.attributes[i].name + '="' + elmt.attributes[i].value + '"';
  }
  if (elmt.childNodes.length == 0) {
    str += ' /';  // show as empty tag
  }
  str += '>';  // close tag
  return str;
}

/**
 * For debug traces, summarize a tag without including its children/contents
 * @param elmt Any HTML element
 * @returns A recreation of its start tag
 */
function debugLocateTag(elmt:Element, fullPath:boolean): string {
  let elementStr = elmt.outerHTML;
  let pageStr = _rawHtmlSource;
  let elementIndex = pageStr.indexOf(elementStr);
  if (elementIndex < 0) {
    elementStr = '<' + elmt.localName;
    elementIndex = Math.max(0, pageStr.indexOf(elementStr));
  }
  let contentAbove = pageStr.substring(0, elementIndex);
  let linesAbove = contentAbove.split('\n');
  let lineNumber = linesAbove.length;  // start at line 1
  let column = linesAbove[lineNumber - 1].length;

  let fileName = fullPath 
    ? (window.location.protocol + '//' + window.location.pathname)
    : ('./' + window.location.pathname.split("/").pop());
  return `${fileName}:${lineNumber}:${column}`;
}

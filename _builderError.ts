
/**
 * For debug traces, summarize a tag without including its children/contents
 * @param elmt Any HTML element
 * @returns A recreation of its start tag
 */
function debugTagAttrs(elmt:Element): string {
  let str = '<' + elmt.tagName;
  for (let i = 0; i < elmt.attributes.length; i++) {
    str += ' ' + elmt.attributes[i].name + '="' + elmt.attributes[i].value + '"';
  }
  if (elmt.childNodes.length == 0) {
    str += ' /';  // show as empty tag
  }
  str += '>';  // close tag
  return str;
}

/**
 * Convert an error's stack trace (run-on text stream) into a list.
 * @param ex An error. Better yet, a BuildError-derived error.
 * @returns The stack as a list, where item 0 is the message.
 * If ex is a BuildError, re-use the cached stack read.
 */
function stackAsList(ex:Error):string[] {
  if ((<BuildError>ex).relativeStack) {  // instanceof BuildError
    return (<BuildError>ex).relativeStack;
  }

  if (!ex.stack) {
    return [];
  }
  return ex.stack.split('\n');
}

/**
 * Make a stack at the current callstack, by faking an exception.
 * @param remove A list of functions to remove - the debug infrastructure to capture these callstacks.
 * @param summary The correct first line of the stack, to replace a generic one generated by the fake exception.
 * @returns A callstack as a list
 */
function debugMakeStack(remove:string[], summary?:string):string[] {
  const ex = new Error();
  const stack = stackAsList(ex);
  cleanStack(stack, ['stackAsList', 'debugMakeStack']);
  cleanStack(stack, remove, summary);
  return stack;
}

/**
 * Compare an outer and inner/causal callstack.
 * @param err The inner exception.
 * @param caller The callstack (as a list) of the outer/calling exception.
 * @returns The portion of inner's callstack that adds to the callstack of the caller.
 */
function simplifyRelativeStack(err:Error, caller:string[]):string[] {
  let inner:string[] = stackAsList(err);
  let firstAt = 0;
  while (firstAt < inner.length && inner[firstAt].indexOf(' at ') < 0) {
    firstAt++;
  }

  for (let i = firstAt; i < inner.length; i++) {
    for (var c = 0; c < caller.length; c++) {
        if (inner[i] == caller[c]) {
            // Found first match. Remove everything in inner from here on.
            inner.splice(i, inner.length - i);
            return inner;
        }
    }
  }
  return inner;
}

/**
 * Clean a callstack by removing the infrastructure for getting callstacks.
 * @param stack The callstack to modify.
 * @param remove The function entries to remove.
 * @param summary An optional new summary message (line 0)
 */
function cleanStack(stack:string[], remove:string[], summary?:string) {
  let firstAt = 0;
  while (firstAt < stack.length && stack[firstAt].indexOf(' at ') < 0) {
    firstAt++;
  }
  let cleaned = true;
  while (stack.length > firstAt && cleaned) {
    for (var i = 0; i < remove.length; i++) {
      cleaned = false;
      if (stack[firstAt].indexOf(remove[i]) >= 0) {
        stack.splice(firstAt, 1);
        cleaned = true;
        break;
      }
    }
  }

  if (summary) {
    if (firstAt > 0) {
      stack[0] = summary;
    }
  }
}

/**
 * Create an error message, which also mentions causal messages (if any)
 * @param msg The current error message
 * @param cause An inner exception (which could have nested inners)
 * @returns Either the original message, or the message combined with nested messages.
 */
function concatErrorMessage(msg:string, cause?:Error) {
  if (!cause) {
    return msg;
  }
  return msg + "\n caused by " + cause.message;
}

/**
 * Custom error which can track nested exceptions
 */
export class BuildError extends Error {
  cause: Error|undefined;
  relativeStack: string[];

  /**
   * Create a new BuildError (or derived error)
   * @param msg The message of the Error
   * @param inner The inner/causal error, if any
   * @param cls The name of the derived class, if any
   */
  constructor(msg: string, inner?:Error, cls?:string) {
    super(concatErrorMessage(cls + ": " + msg, inner));
    this.name = 'BuildError';
    this.cause = inner;
    this.relativeStack = debugMakeStack(['.BuildError', 'new Build'], (cls || "BuildError") + ": " + msg);

    if (inner) {
      const innermost = simplifyRelativeStack(inner, this.relativeStack);
      if ((<BuildError>inner).relativeStack) {  // instanceof BuildError
        (<BuildError>inner).relativeStack = innermost;
        inner.stack = innermost.join('\n');
      }
    }
  }
}

/**
 * Track build errors that occur while evaluating context expressions.
 * Intended use is 1-per-function, in a function-wide try/catch
 */
export class BuildEvalError extends BuildError {
  raw: string;

  /**
   * @param func The name of the function.
   * @param inner The inner/causal error, if any
   * @param cls The name of the derived class, if any
   */
  constructor(func: string, raw:string, inner?:Error, cls?:string) {
    super(func + '(' + raw + ')', inner, cls || "BuildEvalError");
    this.name = 'BuildEvalError';
    this.raw = raw;
  }
}

/**
 * Track build errors that occur while evaluating build tags.
 * Intended use is 1-per-function, in a function-wide try/catch
 */
export class BuildTagError extends BuildError {
  tag: string;

  /**
   * @param func The name of the function.
   * @param inner The inner/causal error, if any
   * @param cls The name of the derived class, if any
   */
  constructor(func: string, elmt:Element, inner?:Error, cls?:string) {
    super(func + '(' + debugTagAttrs(elmt) + ')', inner, cls || "BuildTagError");
    this.name = 'BuildTagError';
    this.tag = debugTagAttrs(elmt);
  }
}

